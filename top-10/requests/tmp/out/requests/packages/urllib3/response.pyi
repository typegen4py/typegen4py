import io
from ._collections import HTTPHeaderDict as HTTPHeaderDict
from .connection import BaseSSLError as BaseSSLError, HTTPException as HTTPException
from .exceptions import DecodeError as DecodeError, ProtocolError as ProtocolError, ReadTimeoutError as ReadTimeoutError, ResponseNotChunked as ResponseNotChunked
from .util.response import is_fp_closed as is_fp_closed, is_response_to_head as is_response_to_head
from typing import Any, Optional

class DeflateDecoder:
    def __init__(self) -> None: ...
    def __getattr__(self, name: Any): ...
    def decompress(self, data: Any): ...

class GzipDecoder:
    def __init__(self) -> None: ...
    def __getattr__(self, name: Any): ...
    def decompress(self, data: Any): ...

class HTTPResponse(io.IOBase):
    CONTENT_DECODERS: Any = ...
    REDIRECT_STATUSES: Any = ...
    headers: Any = ...
    status: Any = ...
    version: Any = ...
    reason: Any = ...
    strict: Any = ...
    decode_content: Any = ...
    chunked: bool = ...
    chunk_left: Any = ...
    def __init__(self, body: str = ..., headers: Optional[Any] = ..., status: int = ..., version: int = ..., reason: Optional[Any] = ..., strict: int = ..., preload_content: bool = ..., decode_content: bool = ..., original_response: Optional[Any] = ..., pool: Optional[Any] = ..., connection: Optional[Any] = ...) -> None: ...
    def get_redirect_location(self): ...
    def release_conn(self) -> None: ...
    @property
    def data(self): ...
    def tell(self): ...
    def read(self, amt: Optional[Any] = ..., decode_content: Optional[Any] = ..., cache_content: bool = ...): ...
    def stream(self, amt: Any = ..., decode_content: Optional[Any] = ...) -> None: ...
    @classmethod
    def from_httplib(ResponseCls: Any, r: Any, **response_kw: Any): ...
    def getheaders(self): ...
    def getheader(self, name: Any, default: Optional[Any] = ...): ...
    def close(self) -> None: ...
    @property
    def closed(self): ...
    def fileno(self): ...
    def flush(self): ...
    def readable(self): ...
    def readinto(self, b: Any): ...
    def read_chunked(self, amt: Optional[Any] = ..., decode_content: Optional[Any] = ...) -> None: ...
