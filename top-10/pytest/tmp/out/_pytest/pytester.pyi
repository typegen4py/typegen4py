import os
import pexpect
import py
from _pytest import timing as timing
from _pytest._code import Source as Source
from _pytest.compat import final as final
from _pytest.config import Config as Config, ExitCode as ExitCode, PytestPluginManager as PytestPluginManager, hookimpl as hookimpl, main as main
from _pytest.config.argparsing import Parser as Parser
from _pytest.deprecated import check_ispytest as check_ispytest
from _pytest.fixtures import FixtureRequest as FixtureRequest, fixture as fixture
from _pytest.main import Session as Session
from _pytest.monkeypatch import MonkeyPatch as MonkeyPatch
from _pytest.nodes import Collector as Collector, Item as Item
from _pytest.outcomes import fail as fail, importorskip as importorskip, skip as skip
from _pytest.pathlib import make_numbered_dir as make_numbered_dir
from _pytest.reports import CollectReport as CollectReport, TestReport as TestReport
from _pytest.tmpdir import TempPathFactory as TempPathFactory
from _pytest.warning_types import PytestWarning as PytestWarning
from iniconfig import SectionWrapper as SectionWrapper
from pathlib import Path
from typing import Any, Callable, Dict, Generator, Iterable, List, Optional, Sequence, TextIO, Tuple, Type, Union
from typing_extensions import Literal as Literal

pytest_plugins: Any
IGNORE_PAM: Any

def pytest_addoption(parser: Parser) -> None: ...
def pytest_configure(config: Config) -> None: ...

class LsofFdLeakChecker:
    def get_open_files(self) -> List[Tuple[str, str]]: ...
    def matching_platform(self) -> bool: ...
    def pytest_runtest_protocol(self, item: Item) -> Generator[None, None, None]: ...

class PytestArg:
    def __init__(self, request: FixtureRequest) -> None: ...
    def gethookrecorder(self, hook: Any) -> HookRecorder: ...

def get_public_names(values: Iterable[str]) -> List[str]: ...

class ParsedCall:
    def __init__(self, name: str, kwargs: Any) -> None: ...
    def __getattr__(self, key: str) -> Any: ...

class HookRecorder:
    calls: Any = ...
    ret: Any = ...
    def __init__(self, pluginmanager: PytestPluginManager) -> None: ...
    def finish_recording(self) -> None: ...
    def getcalls(self, names: Union[str, Iterable[str]]) -> List[ParsedCall]: ...
    def assert_contains(self, entries: Sequence[Tuple[str, str]]) -> None: ...
    def popcall(self, name: str) -> ParsedCall: ...
    def getcall(self, name: str) -> ParsedCall: ...
    def getreports(self, names: Literal[pytest_collectreport]) -> Sequence[CollectReport]: ...
    def getreports(self, names: Literal[pytest_runtest_logreport]) -> Sequence[TestReport]: ...
    def getreports(self, names: Union[str, Iterable[str]]=...) -> Sequence[Union[CollectReport, TestReport]]: ...
    def getreports(self, names: Union[str, Iterable[str]]=...) -> Sequence[Union[CollectReport, TestReport]]: ...
    def matchreport(self, inamepart: str=..., names: Union[str, Iterable[str]]=..., when: Optional[str]=...) -> Union[CollectReport, TestReport]: ...
    def getfailures(self, names: Literal[pytest_collectreport]) -> Sequence[CollectReport]: ...
    def getfailures(self, names: Literal[pytest_runtest_logreport]) -> Sequence[TestReport]: ...
    def getfailures(self, names: Union[str, Iterable[str]]=...) -> Sequence[Union[CollectReport, TestReport]]: ...
    def getfailures(self, names: Union[str, Iterable[str]]=...) -> Sequence[Union[CollectReport, TestReport]]: ...
    def getfailedcollections(self) -> Sequence[CollectReport]: ...
    def listoutcomes(self) -> Tuple[Sequence[TestReport], Sequence[Union[CollectReport, TestReport]], Sequence[Union[CollectReport, TestReport]]]: ...
    def countoutcomes(self) -> List[int]: ...
    def assertoutcome(self, passed: int=..., skipped: int=..., failed: int=...) -> None: ...
    def clear(self) -> None: ...

def linecomp() -> LineComp: ...
def LineMatcher_fixture(request: FixtureRequest) -> Type[LineMatcher]: ...
def pytester(request: FixtureRequest, tmp_path_factory: TempPathFactory) -> Pytester: ...
def testdir(pytester: Pytester) -> Testdir: ...

rex_session_duration: Any
rex_outcome: Any

class RunResult:
    ret: Any = ...
    outlines: Any = ...
    errlines: Any = ...
    stdout: Any = ...
    stderr: Any = ...
    duration: Any = ...
    def __init__(self, ret: Union[int, ExitCode], outlines: List[str], errlines: List[str], duration: float) -> None: ...
    def parseoutcomes(self) -> Dict[str, int]: ...
    @classmethod
    def parse_summary_nouns(cls: Any, lines: Any) -> Dict[str, int]: ...
    def assert_outcomes(self, passed: int=..., skipped: int=..., failed: int=..., errors: int=..., xpassed: int=..., xfailed: int=...) -> None: ...

class CwdSnapshot:
    def __init__(self) -> None: ...
    def restore(self) -> None: ...

class SysModulesSnapshot:
    def __init__(self, preserve: Optional[Callable[[str], bool]]=...) -> None: ...
    def restore(self) -> None: ...

class SysPathsSnapshot:
    def __init__(self) -> None: ...
    def restore(self) -> None: ...

class Pytester:
    __test__: bool = ...
    CLOSE_STDIN: Any = ...
    class TimeoutExpired(Exception): ...
    plugins: Any = ...
    def __init__(self, request: FixtureRequest, tmp_path_factory: TempPathFactory, *, _ispytest: bool=...) -> None: ...
    @property
    def path(self) -> Path: ...
    def make_hook_recorder(self, pluginmanager: PytestPluginManager) -> HookRecorder: ...
    def chdir(self) -> None: ...
    def makefile(self, ext: str, *args: str, **kwargs: str) -> Path: ...
    def makeconftest(self, source: str) -> Path: ...
    def makeini(self, source: str) -> Path: ...
    def getinicfg(self, source: str) -> SectionWrapper: ...
    def makepyprojecttoml(self, source: str) -> Path: ...
    def makepyfile(self, *args: Any, **kwargs: Any) -> Path: ...
    def maketxtfile(self, *args: Any, **kwargs: Any) -> Path: ...
    def syspathinsert(self, path: Optional[Union[str, os.PathLike[str]]]=...) -> None: ...
    def mkdir(self, name: str) -> Path: ...
    def mkpydir(self, name: str) -> Path: ...
    def copy_example(self, name: Optional[str]=...) -> Path: ...
    Session: Any = ...
    def getnode(self, config: Config, arg: Union[str, os.PathLike[str]]) -> Optional[Union[Collector, Item]]: ...
    def getpathnode(self, path: Union[str, os.PathLike[str]]) -> Any: ...
    def genitems(self, colitems: Sequence[Union[Item, Collector]]) -> List[Item]: ...
    def runitem(self, source: str) -> Any: ...
    def inline_runsource(self, source: str, *cmdlineargs: Any) -> HookRecorder: ...
    def inline_genitems(self, *args: Any) -> Tuple[List[Item], HookRecorder]: ...
    def inline_run(self, *args: Union[str, os.PathLike[str]], plugins: Any=..., no_reraise_ctrlc: bool=...) -> HookRecorder: ...
    def runpytest_inprocess(self, *args: Union[str, os.PathLike[str]], **kwargs: Any) -> RunResult: ...
    def runpytest(self, *args: Union[str, os.PathLike[str]], **kwargs: Any) -> RunResult: ...
    def parseconfig(self, *args: Union[str, os.PathLike[str]]) -> Config: ...
    def parseconfigure(self, *args: Union[str, os.PathLike[str]]) -> Config: ...
    def getitem(self, source: str, funcname: str=...) -> Item: ...
    def getitems(self, source: str) -> List[Item]: ...
    config: Any = ...
    def getmodulecol(self, source: Union[str, Path], configargs: Any=..., *, withinit: bool=...) -> Any: ...
    def collect_by_name(self, modcol: Collector, name: str) -> Optional[Union[Item, Collector]]: ...
    def popen(self, cmdargs: Any, stdout: Union[int, TextIO]=..., stderr: Union[int, TextIO]=..., stdin: Any=..., **kw: Any) -> Any: ...
    def run(self, *cmdargs: Union[str, os.PathLike[str]], timeout: Optional[float]=..., stdin: Any=...) -> RunResult: ...
    def runpython(self, script: Any) -> RunResult: ...
    def runpython_c(self, command: Any): ...
    def runpytest_subprocess(self, *args: Any, timeout: Optional[float]=...) -> RunResult: ...
    def spawn_pytest(self, string: str, expect_timeout: float=...) -> pexpect.spawn: ...
    def spawn(self, cmd: str, expect_timeout: float=...) -> pexpect.spawn: ...

class LineComp:
    stringio: Any = ...
    def __init__(self) -> None: ...
    def assert_contains_lines(self, lines2: Sequence[str]) -> None: ...

class Testdir:
    __test__: bool = ...
    CLOSE_STDIN: Any = ...
    TimeoutExpired: Any = ...
    Session: Any = ...
    def __init__(self, pytester: Pytester, *, _ispytest: bool=...) -> None: ...
    @property
    def tmpdir(self) -> py.path.local: ...
    @property
    def test_tmproot(self) -> py.path.local: ...
    @property
    def request(self): ...
    @property
    def plugins(self): ...
    @plugins.setter
    def plugins(self, plugins: Any) -> None: ...
    @property
    def monkeypatch(self) -> MonkeyPatch: ...
    def make_hook_recorder(self, pluginmanager: Any) -> HookRecorder: ...
    def chdir(self) -> None: ...
    def finalize(self) -> None: ...
    def makefile(self, ext: Any, *args: Any, **kwargs: Any) -> py.path.local: ...
    def makeconftest(self, source: Any) -> py.path.local: ...
    def makeini(self, source: Any) -> py.path.local: ...
    def getinicfg(self, source: str) -> SectionWrapper: ...
    def makepyprojecttoml(self, source: Any) -> py.path.local: ...
    def makepyfile(self, *args: Any, **kwargs: Any) -> py.path.local: ...
    def maketxtfile(self, *args: Any, **kwargs: Any) -> py.path.local: ...
    def syspathinsert(self, path: Any=...) -> None: ...
    def mkdir(self, name: Any) -> py.path.local: ...
    def mkpydir(self, name: Any) -> py.path.local: ...
    def copy_example(self, name: Any=...) -> py.path.local: ...
    def getnode(self, config: Config, arg: Any) -> Optional[Union[Item, Collector]]: ...
    def getpathnode(self, path: Any): ...
    def genitems(self, colitems: List[Union[Item, Collector]]) -> List[Item]: ...
    def runitem(self, source: Any): ...
    def inline_runsource(self, source: Any, *cmdlineargs: Any): ...
    def inline_genitems(self, *args: Any): ...
    def inline_run(self, *args: Any, plugins: Any=..., no_reraise_ctrlc: bool=...) -> Any: ...
    def runpytest_inprocess(self, *args: Any, **kwargs: Any) -> RunResult: ...
    def runpytest(self, *args: Any, **kwargs: Any) -> RunResult: ...
    def parseconfig(self, *args: Any) -> Config: ...
    def parseconfigure(self, *args: Any) -> Config: ...
    def getitem(self, source: Any, funcname: str = ...): ...
    def getitems(self, source: Any): ...
    def getmodulecol(self, source: Any, configargs: Any = ..., withinit: bool = ...): ...
    def collect_by_name(self, modcol: Collector, name: str) -> Optional[Union[Item, Collector]]: ...
    def popen(self, cmdargs: Any, stdout: Union[int, TextIO]=..., stderr: Union[int, TextIO]=..., stdin: Any=..., **kw: Any) -> Any: ...
    def run(self, *cmdargs: Any, timeout: Any=..., stdin: Any=...) -> RunResult: ...
    def runpython(self, script: Any) -> RunResult: ...
    def runpython_c(self, command: Any): ...
    def runpytest_subprocess(self, *args: Any, timeout: Any=...) -> RunResult: ...
    def spawn_pytest(self, string: str, expect_timeout: float=...) -> pexpect.spawn: ...
    def spawn(self, cmd: str, expect_timeout: float=...) -> pexpect.spawn: ...
    def __init__(self) -> None: ...
    def __lt__(self, other: Any) -> Any: ...
    def __le__(self, other: Any) -> Any: ...
    def __gt__(self, other: Any) -> Any: ...
    def __ge__(self, other: Any) -> Any: ...

class LineMatcher:
    lines: Any = ...
    def __init__(self, lines: List[str]) -> None: ...
    def fnmatch_lines_random(self, lines2: Sequence[str]) -> None: ...
    def re_match_lines_random(self, lines2: Sequence[str]) -> None: ...
    def get_lines_after(self, fnline: str) -> Sequence[str]: ...
    def fnmatch_lines(self, lines2: Sequence[str], *, consecutive: bool=...) -> None: ...
    def re_match_lines(self, lines2: Sequence[str], *, consecutive: bool=...) -> None: ...
    def no_fnmatch_line(self, pat: str) -> None: ...
    def no_re_match_line(self, pat: str) -> None: ...
    def str(self) -> str: ...
