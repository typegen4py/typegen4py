from _pytest._code.code import ExceptionChainRepr as ExceptionChainRepr, ExceptionInfo as ExceptionInfo, ExceptionRepr as ExceptionRepr, ReprEntry as ReprEntry, ReprEntryNative as ReprEntryNative, ReprExceptionInfo as ReprExceptionInfo, ReprFileLocation as ReprFileLocation, ReprFuncArgs as ReprFuncArgs, ReprLocals as ReprLocals, ReprTraceback as ReprTraceback, TerminalRepr as TerminalRepr
from _pytest._io import TerminalWriter as TerminalWriter
from _pytest.compat import final as final
from _pytest.config import Config as Config
from _pytest.nodes import Collector as Collector, Item as Item
from _pytest.outcomes import skip as skip
from _pytest.runner import CallInfo as CallInfo
from typing import Any, Dict, Iterable, Iterator, List, Optional, Tuple, Union
from typing_extensions import Literal as Literal

def getworkerinfoline(node: Any): ...

class BaseReport:
    when: Optional[str]
    location: Optional[Tuple[str, Optional[int], str]]
    longrepr: Union[None, ExceptionInfo[BaseException], Tuple[str, int, str], str, TerminalRepr]
    sections: List[Tuple[str, str]]
    nodeid: str
    def __init__(self, **kw: Any) -> None: ...
    def __getattr__(self, key: str) -> Any: ...
    def toterminal(self, out: TerminalWriter) -> None: ...
    def get_sections(self, prefix: str) -> Iterator[Tuple[str, str]]: ...
    @property
    def longreprtext(self) -> str: ...
    @property
    def caplog(self) -> str: ...
    @property
    def capstdout(self) -> str: ...
    @property
    def capstderr(self) -> str: ...
    passed: Any = ...
    failed: Any = ...
    skipped: Any = ...
    @property
    def fspath(self) -> str: ...
    @property
    def count_towards_summary(self) -> bool: ...
    @property
    def head_line(self) -> Optional[str]: ...

class TestReport(BaseReport):
    __test__: bool = ...
    nodeid: Any = ...
    location: Any = ...
    keywords: Any = ...
    outcome: Any = ...
    longrepr: Any = ...
    when: Any = ...
    user_properties: Any = ...
    sections: Any = ...
    duration: Any = ...
    def __init__(self, nodeid: str, location: Tuple[str, Optional[int], str], keywords: Any, outcome: Literal[passed, failed, skipped], longrepr: Union[None, ExceptionInfo[BaseException], Tuple[str, int, str], str, TerminalRepr], when: Literal[setup, call, teardown], sections: Iterable[Tuple[str, str]]=..., duration: float=..., user_properties: Optional[Iterable[Tuple[str, object]]]=..., **extra: Any) -> None: ...
    @classmethod
    def from_item_and_call(cls: Any, item: Item, call: CallInfo[None]) -> TestReport: ...

class CollectReport(BaseReport):
    when: str = ...
    nodeid: Any = ...
    outcome: Any = ...
    longrepr: Any = ...
    result: Any = ...
    sections: Any = ...
    def __init__(self, nodeid: str, outcome: Literal[passed, skipped, failed], longrepr: Any, result: Optional[List[Union[Item, Collector]]], sections: Iterable[Tuple[str, str]]=..., **extra: Any) -> None: ...
    @property
    def location(self): ...

class CollectErrorRepr(TerminalRepr):
    longrepr: Any = ...
    def __init__(self, msg: str) -> None: ...
    def toterminal(self, out: TerminalWriter) -> None: ...

def pytest_report_to_serializable(report: Union[CollectReport, TestReport]) -> Optional[Dict[str, Any]]: ...
def pytest_report_from_serializable(data: Dict[str, Any]) -> Optional[Union[CollectReport, TestReport]]: ...
