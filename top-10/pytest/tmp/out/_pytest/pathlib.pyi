import os
import py
from _pytest.compat import assert_never as assert_never
from _pytest.outcomes import skip as skip
from _pytest.warning_types import PytestWarning as PytestWarning
from enum import Enum
from pathlib import Path, PurePath
from types import ModuleType
from typing import Any, Callable, Iterable, Iterator, Optional, Set, Union

LOCK_TIMEOUT: Any

def get_lock_path(path: _AnyPurePath) -> _AnyPurePath: ...
def ensure_reset_dir(path: Path) -> None: ...
def on_rm_rf_error(func: Any, path: str, exc: Any, start_path: Path) -> bool: ...
def ensure_extended_length_path(path: Path) -> Path: ...
def get_extended_length_path_str(path: str) -> str: ...
def rm_rf(path: Path) -> None: ...
def find_prefixed(root: Path, prefix: str) -> Iterator[Path]: ...
def extract_suffixes(iter: Iterable[PurePath], prefix: str) -> Iterator[str]: ...
def find_suffixes(root: Path, prefix: str) -> Iterator[str]: ...
def parse_num(maybe_num: Any) -> int: ...
def make_numbered_dir(root: Path, prefix: str) -> Path: ...
def create_cleanup_lock(p: Path) -> Path: ...
def register_cleanup_lock_removal(lock_path: Path, register: Any=...) -> Any: ...
def maybe_delete_a_numbered_dir(path: Path) -> None: ...
def ensure_deletable(path: Path, consider_lock_dead_if_created_before: float) -> bool: ...
def try_cleanup(path: Path, consider_lock_dead_if_created_before: float) -> None: ...
def cleanup_candidates(root: Path, prefix: str, keep: int) -> Iterator[Path]: ...
def cleanup_numbered_dir(root: Path, prefix: str, keep: int, consider_lock_dead_if_created_before: float) -> None: ...
def make_numbered_dir_with_cleanup(root: Path, prefix: str, keep: int, lock_timeout: float) -> Path: ...
def resolve_from_str(input: str, rootpath: Path) -> Path: ...
def fnmatch_ex(pattern: str, path: Any) -> bool: ...
def parts(s: str) -> Set[str]: ...
def symlink_or_skip(src: Any, dst: Any, **kwargs: Any) -> None: ...

class ImportMode(Enum):
    prepend: str = ...
    append: str = ...
    importlib: str = ...

class ImportPathMismatchError(ImportError): ...

def import_path(p: Union[str, py.path.local, Path], *, mode: Union[str, ImportMode]=...) -> ModuleType: ...
def resolve_package_path(path: Path) -> Optional[Path]: ...
def visit(path: str, recurse: Callable[[os.DirEntry[str]], bool]) -> Iterator[os.DirEntry[str]]: ...
def absolutepath(path: Union[Path, str]) -> Path: ...
def commonpath(path1: Path, path2: Path) -> Optional[Path]: ...
def bestrelpath(directory: Path, dest: Path) -> str: ...
