import enum
import types
from typing import Any, Callable, Iterator, Mapping, NoReturn, Optional, Sequence

class TokenType(enum.Enum):
    LPAREN: str = ...
    RPAREN: str = ...
    OR: str = ...
    AND: str = ...
    NOT: str = ...
    IDENT: str = ...
    EOF: str = ...

class Token:
    type: Any = ...
    value: Any = ...
    pos: Any = ...
    def __init__(self, type: Any, value: Any, pos: Any) -> None: ...
    def __lt__(self, other: Any) -> Any: ...
    def __le__(self, other: Any) -> Any: ...
    def __gt__(self, other: Any) -> Any: ...
    def __ge__(self, other: Any) -> Any: ...

class ParseError(Exception):
    column: Any = ...
    message: Any = ...
    def __init__(self, column: int, message: str) -> None: ...

class Scanner:
    tokens: Any = ...
    current: Any = ...
    def __init__(self, input: str) -> None: ...
    def lex(self, input: str) -> Iterator[Token]: ...
    def accept(self, type: TokenType, *, reject: bool=...) -> Optional[Token]: ...
    def reject(self, expected: Sequence[TokenType]) -> NoReturn: ...

class MatcherAdapter(Mapping[str, bool]):
    matcher: Any = ...
    def __init__(self, matcher: Callable[[str], bool]) -> None: ...
    def __getitem__(self, key: str) -> bool: ...
    def __iter__(self) -> Iterator[str]: ...
    def __len__(self) -> int: ...

class Expression:
    code: Any = ...
    def __init__(self, code: types.CodeType) -> None: ...
    @classmethod
    def compile(self, input: str) -> Expression: ...
    def evaluate(self, matcher: Callable[[str], bool]) -> bool: ...
