import io
import socket
import socketserver
import ssl
import typing as t
from .exceptions import InternalServerError as InternalServerError
from .urls import uri_to_iri as uri_to_iri, url_parse as url_parse, url_unquote as url_unquote
from cryptography.hazmat.primitives.asymmetric.rsa import RSAPrivateKeyWithSerialization
from cryptography.x509 import Certificate
from http.server import BaseHTTPRequestHandler, HTTPServer
from typing import Any, Optional
from wsgiref.types import WSGIApplication as WSGIApplication, WSGIEnvironment as WSGIEnvironment

class _SslDummy:
    def __getattr__(self, name: Any) -> None: ...

can_fork: Any
ForkingMixIn = socketserver.ForkingMixIn

class ForkingMixIn: ...

af_unix: Any
LISTEN_QUEUE: int
can_open_by_fd: Any

class DechunkedInput(io.RawIOBase):
    def __init__(self, rfile: t.BinaryIO) -> None: ...
    def readable(self) -> bool: ...
    def read_chunk_len(self) -> int: ...
    def readinto(self, buf: bytearray) -> int: ...

class WSGIRequestHandler(BaseHTTPRequestHandler):
    server: BaseWSGIServer
    @property
    def server_version(self) -> str: ...
    client_address: Any = ...
    def make_environ(self) -> WSGIEnvironment: ...
    environ: Any = ...
    close_connection: bool = ...
    def run_wsgi(self) -> None: ...
    def handle(self) -> None: ...
    def initiate_shutdown(self) -> None: ...
    def connection_dropped(self, error: BaseException, environ: t.Optional[WSGIEnvironment]=...) -> None: ...
    raw_requestline: Any = ...
    def handle_one_request(self) -> None: ...
    def send_response(self, code: int, message: t.Optional[str]=...) -> None: ...
    def version_string(self) -> str: ...
    def address_string(self) -> str: ...
    def port_integer(self) -> int: ...
    def log_request(self, code: t.Union[int, str]=..., size: t.Union[int, str]=...) -> Any: ...
    def log_error(self, *args: Any) -> None: ...
    def log_message(self, format: str, *args: Any) -> None: ...
    def log(self, type: str, message: str, *args: Any) -> None: ...

def generate_adhoc_ssl_pair(cn: t.Optional[str]=...) -> t.Tuple[Certificate, RSAPrivateKeyWithSerialization]: ...
def make_ssl_devcert(base_path: str, host: t.Optional[str]=..., cn: t.Optional[str]=...) -> t.Tuple[str, str]: ...
def generate_adhoc_ssl_context() -> ssl.SSLContext: ...
def load_ssl_context(cert_file: str, pkey_file: t.Optional[str]=..., protocol: t.Optional[int]=...) -> ssl.SSLContext: ...
def is_ssl_error(error: Optional[Any] = ...): ...
def select_address_family(host: str, port: int) -> socket.AddressFamily: ...
def get_sockaddr(host: str, port: int, family: socket.AddressFamily) -> t.Union[t.Tuple[str, int], str]: ...
def get_interface_ip(family: socket.AddressFamily) -> Any: ...

class BaseWSGIServer(HTTPServer):
    multithread: bool = ...
    multiprocess: bool = ...
    request_queue_size: Any = ...
    address_family: Any = ...
    app: Any = ...
    passthrough_errors: Any = ...
    shutdown_signal: bool = ...
    host: Any = ...
    port: Any = ...
    socket: Any = ...
    server_address: Any = ...
    ssl_context: Any = ...
    def __init__(self, host: str, port: int, app: WSGIApplication, handler: t.Optional[t.Type[WSGIRequestHandler]]=..., passthrough_errors: bool=..., ssl_context: t.Optional[_TSSLContextArg]=..., fd: t.Optional[int]=...) -> None: ...
    def log(self, type: str, message: str, *args: Any) -> None: ...
    def serve_forever(self, poll_interval: Any=...) -> None: ...
    def handle_error(self, request: t.Any, client_address: t.Tuple[str, int]) -> None: ...

class ThreadedWSGIServer(socketserver.ThreadingMixIn, BaseWSGIServer):
    multithread: bool = ...
    daemon_threads: bool = ...

class ForkingWSGIServer(ForkingMixIn, BaseWSGIServer):
    multiprocess: bool = ...
    max_children: Any = ...
    def __init__(self, host: str, port: int, app: WSGIApplication, processes: int=..., handler: t.Optional[t.Type[WSGIRequestHandler]]=..., passthrough_errors: bool=..., ssl_context: t.Optional[_TSSLContextArg]=..., fd: t.Optional[int]=...) -> None: ...

def make_server(host: str, port: int, app: WSGIApplication, threaded: bool=..., processes: int=..., request_handler: t.Optional[t.Type[WSGIRequestHandler]]=..., passthrough_errors: bool=..., ssl_context: t.Optional[_TSSLContextArg]=..., fd: t.Optional[int]=...) -> BaseWSGIServer: ...
def is_running_from_reloader() -> bool: ...
def run_simple(hostname: str, port: int, application: WSGIApplication, use_reloader: bool=..., use_debugger: bool=..., use_evalex: bool=..., extra_files: t.Optional[t.Iterable[str]]=..., exclude_patterns: t.Optional[t.Iterable[str]]=..., reloader_interval: int=..., reloader_type: str=..., threaded: bool=..., processes: int=..., request_handler: t.Optional[t.Type[WSGIRequestHandler]]=..., static_files: t.Optional[t.Dict[str, t.Union[str, t.Tuple[str, str]]]]=..., passthrough_errors: bool=..., ssl_context: t.Optional[_TSSLContextArg]=...) -> None: ...
def run_with_reloader(*args: Any, **kwargs: Any) -> None: ...
def main() -> None: ...
