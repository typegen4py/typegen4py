import typing as t
from .datastructures import WWWAuthenticate as WWWAuthenticate
from .sansio.response import Response as Response
from datetime import datetime
from typing import Any
from wsgiref.types import StartResponse, WSGIEnvironment as WSGIEnvironment

class HTTPException(Exception):
    code: t.Optional[int] = ...
    description: t.Optional[str] = ...
    response: Any = ...
    def __init__(self, description: t.Optional[str]=..., response: t.Optional[Response]=...) -> None: ...
    @classmethod
    def wrap(cls: Any, exception: t.Type[BaseException], name: t.Optional[str]=...) -> t.Type[HTTPException]: ...
    @property
    def name(self) -> str: ...
    def get_description(self, environ: t.Optional[WSGIEnvironment]=..., scope: t.Optional[dict]=...) -> str: ...
    def get_body(self, environ: t.Optional[WSGIEnvironment]=..., scope: t.Optional[dict]=...) -> str: ...
    def get_headers(self, environ: t.Optional[WSGIEnvironment]=..., scope: t.Optional[dict]=...) -> t.List[t.Tuple[str, str]]: ...
    def get_response(self, environ: t.Optional[WSGIEnvironment]=..., scope: t.Optional[dict]=...) -> Response: ...
    def __call__(self, environ: WSGIEnvironment, start_response: StartResponse) -> t.Iterable[bytes]: ...

class BadRequest(HTTPException):
    code: int = ...
    description: str = ...

class ClientDisconnected(BadRequest): ...
class SecurityError(BadRequest): ...
class BadHost(BadRequest): ...

class Unauthorized(HTTPException):
    code: int = ...
    description: str = ...
    www_authenticate: Any = ...
    def __init__(self, description: t.Optional[str]=..., response: t.Optional[Response]=..., www_authenticate: t.Optional[t.Union[WWWAuthenticate, t.Iterable[WWWAuthenticate]]]=...) -> None: ...
    def get_headers(self, environ: t.Optional[WSGIEnvironment]=..., scope: t.Optional[dict]=...) -> t.List[t.Tuple[str, str]]: ...

class Forbidden(HTTPException):
    code: int = ...
    description: str = ...

class NotFound(HTTPException):
    code: int = ...
    description: str = ...

class MethodNotAllowed(HTTPException):
    code: int = ...
    description: str = ...
    valid_methods: Any = ...
    def __init__(self, valid_methods: t.Optional[t.Iterable[str]]=..., description: t.Optional[str]=..., response: t.Optional[Response]=...) -> None: ...
    def get_headers(self, environ: t.Optional[WSGIEnvironment]=..., scope: t.Optional[dict]=...) -> t.List[t.Tuple[str, str]]: ...

class NotAcceptable(HTTPException):
    code: int = ...
    description: str = ...

class RequestTimeout(HTTPException):
    code: int = ...
    description: str = ...

class Conflict(HTTPException):
    code: int = ...
    description: str = ...

class Gone(HTTPException):
    code: int = ...
    description: str = ...

class LengthRequired(HTTPException):
    code: int = ...
    description: str = ...

class PreconditionFailed(HTTPException):
    code: int = ...
    description: str = ...

class RequestEntityTooLarge(HTTPException):
    code: int = ...
    description: str = ...

class RequestURITooLarge(HTTPException):
    code: int = ...
    description: str = ...

class UnsupportedMediaType(HTTPException):
    code: int = ...
    description: str = ...

class RequestedRangeNotSatisfiable(HTTPException):
    code: int = ...
    description: str = ...
    length: Any = ...
    units: Any = ...
    def __init__(self, length: t.Optional[int]=..., units: str=..., description: t.Optional[str]=..., response: t.Optional[Response]=...) -> None: ...
    def get_headers(self, environ: t.Optional[WSGIEnvironment]=..., scope: t.Optional[dict]=...) -> t.List[t.Tuple[str, str]]: ...

class ExpectationFailed(HTTPException):
    code: int = ...
    description: str = ...

class ImATeapot(HTTPException):
    code: int = ...
    description: str = ...

class UnprocessableEntity(HTTPException):
    code: int = ...
    description: str = ...

class Locked(HTTPException):
    code: int = ...
    description: str = ...

class FailedDependency(HTTPException):
    code: int = ...
    description: str = ...

class PreconditionRequired(HTTPException):
    code: int = ...
    description: str = ...

class _RetryAfter(HTTPException):
    retry_after: Any = ...
    def __init__(self, description: t.Optional[str]=..., response: t.Optional[Response]=..., retry_after: t.Optional[t.Union[datetime, int]]=...) -> None: ...
    def get_headers(self, environ: t.Optional[WSGIEnvironment]=..., scope: t.Optional[dict]=...) -> t.List[t.Tuple[str, str]]: ...

class TooManyRequests(_RetryAfter):
    code: int = ...
    description: str = ...

class RequestHeaderFieldsTooLarge(HTTPException):
    code: int = ...
    description: str = ...

class UnavailableForLegalReasons(HTTPException):
    code: int = ...
    description: str = ...

class InternalServerError(HTTPException):
    code: int = ...
    description: str = ...
    original_exception: Any = ...
    def __init__(self, description: t.Optional[str]=..., response: t.Optional[Response]=..., original_exception: t.Optional[BaseException]=...) -> None: ...

class NotImplemented(HTTPException):
    code: int = ...
    description: str = ...

class BadGateway(HTTPException):
    code: int = ...
    description: str = ...

class ServiceUnavailable(_RetryAfter):
    code: int = ...
    description: str = ...

class GatewayTimeout(HTTPException):
    code: int = ...
    description: str = ...

class HTTPVersionNotSupported(HTTPException):
    code: int = ...
    description: str = ...

default_exceptions: t.Dict[int, t.Type[HTTPException]]

class Aborter:
    mapping: Any = ...
    def __init__(self, mapping: t.Optional[t.Dict[int, t.Type[HTTPException]]]=..., extra: t.Optional[t.Dict[int, t.Type[HTTPException]]]=...) -> None: ...
    def __call__(self, code: t.Union[int, Response], *args: Any, **kwargs: Any) -> t.NoReturn: ...

def abort(status: t.Union[int, Response], *args: Any, **kwargs: Any) -> t.NoReturn: ...

BadRequestKeyError: Any
