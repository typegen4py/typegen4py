import io
import typing as t
from .sansio.utils import host_is_trusted as host_is_trusted
from .urls import _URLTuple, uri_to_iri as uri_to_iri, url_join as url_join, url_parse as url_parse, url_quote as url_quote
from typing import Any
from wsgiref.types import WSGIApplication as WSGIApplication, WSGIEnvironment as WSGIEnvironment

def responder(f: t.Callable[..., WSGIApplication]) -> WSGIApplication: ...
def get_current_url(environ: WSGIEnvironment, root_only: bool=..., strip_querystring: bool=..., host_only: bool=..., trusted_hosts: t.Optional[t.Iterable[str]]=...) -> str: ...
def get_host(environ: WSGIEnvironment, trusted_hosts: t.Optional[t.Iterable[str]]=...) -> str: ...
def get_content_length(environ: WSGIEnvironment) -> t.Optional[int]: ...
def get_input_stream(environ: WSGIEnvironment, safe_fallback: bool=...) -> t.BinaryIO: ...
def get_query_string(environ: WSGIEnvironment) -> str: ...
def get_path_info(environ: WSGIEnvironment, charset: str=..., errors: str=...) -> str: ...
def get_script_name(environ: WSGIEnvironment, charset: str=..., errors: str=...) -> str: ...
def pop_path_info(environ: WSGIEnvironment, charset: str=..., errors: str=...) -> t.Optional[str]: ...
def peek_path_info(environ: WSGIEnvironment, charset: str=..., errors: str=...) -> t.Optional[str]: ...
def extract_path_info(environ_or_baseurl: t.Union[str, WSGIEnvironment], path_or_url: t.Union[str, _URLTuple], charset: str=..., errors: str=..., collapse_http_schemes: bool=...) -> t.Optional[str]: ...

class ClosingIterator:
    def __init__(self, iterable: t.Iterable[bytes], callbacks: t.Optional[t.Union[t.Callable[[], None], t.Iterable[t.Callable[[], None]]]]=...) -> None: ...
    def __iter__(self) -> ClosingIterator: ...
    def __next__(self) -> bytes: ...
    def close(self) -> None: ...

def wrap_file(environ: WSGIEnvironment, file: t.BinaryIO, buffer_size: int=...) -> t.Iterable[bytes]: ...

class FileWrapper:
    file: Any = ...
    buffer_size: Any = ...
    def __init__(self, file: t.BinaryIO, buffer_size: int=...) -> None: ...
    def close(self) -> None: ...
    def seekable(self) -> bool: ...
    def seek(self, *args: Any) -> None: ...
    def tell(self) -> t.Optional[int]: ...
    def __iter__(self) -> FileWrapper: ...
    def __next__(self) -> bytes: ...

class _RangeWrapper:
    iterable: Any = ...
    byte_range: Any = ...
    start_byte: Any = ...
    end_byte: Any = ...
    read_length: int = ...
    seekable: Any = ...
    end_reached: bool = ...
    def __init__(self, iterable: t.Union[t.Iterable[bytes], t.BinaryIO], start_byte: int=..., byte_range: t.Optional[int]=...) -> None: ...
    def __iter__(self) -> _RangeWrapper: ...
    def __next__(self) -> bytes: ...
    def close(self) -> None: ...

def make_line_iter(stream: t.Union[t.Iterable[bytes], t.BinaryIO], limit: t.Optional[int]=..., buffer_size: int=..., cap_at_buffer: bool=...) -> t.Iterator[bytes]: ...
def make_chunk_iter(stream: t.Union[t.Iterable[bytes], t.BinaryIO], separator: bytes, limit: t.Optional[int]=..., buffer_size: int=..., cap_at_buffer: bool=...) -> t.Iterator[bytes]: ...

class LimitedStream(io.IOBase):
    limit: Any = ...
    def __init__(self, stream: t.BinaryIO, limit: int) -> None: ...
    def __iter__(self) -> LimitedStream: ...
    @property
    def is_exhausted(self) -> bool: ...
    def on_exhausted(self) -> bytes: ...
    def on_disconnect(self) -> bytes: ...
    def exhaust(self, chunk_size: int=...) -> None: ...
    def read(self, size: t.Optional[int]=...) -> bytes: ...
    def readline(self, size: t.Optional[int]=...) -> bytes: ...
    def readlines(self, size: t.Optional[int]=...) -> t.List[bytes]: ...
    def tell(self) -> int: ...
    def __next__(self) -> bytes: ...
    def readable(self) -> bool: ...
