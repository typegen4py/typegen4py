import typing as t
import typing_extensions as te
from ..datastructures import Headers as Headers
from ..http import remove_entity_headers as remove_entity_headers
from ..sansio.response import Response as _SansIOResponse
from ..urls import iri_to_uri as iri_to_uri, url_join as url_join
from ..utils import cached_property as cached_property
from ..wsgi import ClosingIterator as ClosingIterator, get_current_url as get_current_url
from http import HTTPStatus
from typing import Any
from werkzeug.http import generate_etag as generate_etag, http_date as http_date, is_resource_modified as is_resource_modified, parse_etags as parse_etags, parse_range_header as parse_range_header
from wsgiref.types import StartResponse, WSGIApplication as WSGIApplication, WSGIEnvironment as WSGIEnvironment

class Response(_SansIOResponse):
    implicit_sequence_conversion: bool = ...
    autocorrect_location_header: bool = ...
    automatically_set_content_length: bool = ...
    response: t.Union[t.Iterable[str], t.Iterable[bytes]]
    direct_passthrough: Any = ...
    def __init__(self, response: t.Optional[t.Union[t.Iterable[bytes], bytes, t.Iterable[str], str]]=..., status: t.Optional[t.Union[int, str, HTTPStatus]]=..., headers: t.Optional[t.Union[t.Mapping[str, t.Union[str, int, t.Iterable[t.Union[str, int]]]], t.Iterable[t.Tuple[str, t.Union[str, int]]]]]=..., mimetype: t.Optional[str]=..., content_type: t.Optional[str]=..., direct_passthrough: bool=...) -> None: ...
    def call_on_close(self, func: t.Callable[[], t.Any]) -> t.Callable[[], t.Any]: ...
    @classmethod
    def force_type(cls: Any, response: Response, environ: t.Optional[WSGIEnvironment]=...) -> Response: ...
    @classmethod
    def from_app(cls: Any, app: WSGIApplication, environ: WSGIEnvironment, buffered: bool=...) -> Response: ...
    def get_data(self, as_text: te.Literal[False]=...) -> bytes: ...
    def get_data(self, as_text: te.Literal[True]) -> str: ...
    def get_data(self, as_text: bool = ...): ...
    def set_data(self, value: t.Union[bytes, str]) -> None: ...
    data: Any = ...
    def calculate_content_length(self) -> t.Optional[int]: ...
    def make_sequence(self) -> None: ...
    def iter_encoded(self) -> t.Iterator[bytes]: ...
    @property
    def is_streamed(self) -> bool: ...
    @property
    def is_sequence(self) -> bool: ...
    def close(self) -> None: ...
    def __enter__(self) -> Response: ...
    def __exit__(self, exc_type: Any, exc_value: Any, tb: Any) -> None: ...
    def freeze(self, no_etag: None=...) -> None: ...
    def get_wsgi_headers(self, environ: WSGIEnvironment) -> Headers: ...
    def get_app_iter(self, environ: WSGIEnvironment) -> t.Iterable[bytes]: ...
    def get_wsgi_response(self, environ: WSGIEnvironment) -> t.Tuple[t.Iterable[bytes], str, t.List[t.Tuple[str, str]]]: ...
    def __call__(self, environ: WSGIEnvironment, start_response: StartResponse) -> t.Iterable[bytes]: ...
    json_module: Any = ...
    @property
    def json(self) -> t.Optional[t.Any]: ...
    def get_json(self, force: bool=..., silent: bool=...) -> t.Optional[t.Any]: ...
    def stream(self) -> ResponseStream: ...
    status_code: int = ...
    def make_conditional(self, request_or_environ: WSGIEnvironment, accept_ranges: t.Union[bool, str]=..., complete_length: t.Optional[int]=...) -> Any: ...
    def add_etag(self, overwrite: bool=..., weak: bool=...) -> None: ...

class ResponseStream:
    mode: str = ...
    response: Any = ...
    closed: bool = ...
    def __init__(self, response: Response) -> None: ...
    def write(self, value: bytes) -> int: ...
    def writelines(self, seq: t.Iterable[bytes]) -> None: ...
    def close(self) -> None: ...
    def flush(self) -> None: ...
    def isatty(self) -> bool: ...
    def tell(self) -> int: ...
    @property
    def encoding(self) -> str: ...

class ResponseStreamMixin:
    def __init__(self, *args: Any, **kwargs: Any) -> None: ...
